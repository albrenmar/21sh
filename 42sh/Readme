Alors l'organisation de mon bordel

D'abord j'init ma structure prompt.

typedef struct	s_cursor
{
	int		prompt;
	int		abs;
	int		x;
	int		y;
	int		legacy;
}				t_cursor;

Int prompt c'est un ft_strlen du prompt (genre le nom du dossier ou on se trouve)
abs c'est la position absolue du curseur, faut imaginer tout ce qu'on tape comme une seule longue ligne, et on a la position du curseur 
dedans. Des qu'on tape un char, qu'on en enleve ou qu;on utilise le curseur, c'est ca qui bouge.

Apres chaque deplacement du curseur, j'apelle void	correct_pos(void).
{
	ab = g_tracking.pos->abs + g_tracking.pos->prompt;
	g_tracking.pos->x = ab % g_tracking.terminfo->sizex;
	g_tracking.pos->y = (ab / g_tracking.terminfo->sizex) + g_tracking.pos->legacy;
}

Donc mon int AB c'est la longueur totale de ma ligne + mon prompt. terminfo->sizex c'est le nombre de colones dans mon terminal.

Genre si mon terminal fait 10 colones, et que ma ligne en fait 30(prompt inclus) je sais que 30/10 9a fera 3, donc 3 ligne.

Si mon curseur est en position 34 de ma string, j'ai mon y, et pour le x je fais un modulo. donc j;ai la position X et Y de mon
curseur(ligne 3, position 4);

Pour ajouter/enlever des char, je fais appel a ma fonction add_to_str.

1) je prend la position absolue de mon curseur(genre "8"). Je me deplace a cet endroit dans la string en utilisant utf_goto(ca 
permet de placer mon pointeur a l;endroit du 8eme character de la string. On peut pas  directement faire str[8] parce que ca peut
foutre la merde avec les character unicode. Y'a pas a s'emmerder avec ca, utf_goto gere tout tout seul)

2) Je fais un str sub de 0 a "position du curseur" et de "position du curseur" jusqu'a la fin(dnc j;ai ma string "start" et "end")

3) Je colle les charactere que je veux ajouter a ma string start, et je recolle end par dessus.

4) Je clear la ligne ou se trouvais mon curseur, et je reprint les modifs


Si vous voulez qu;une touche(genre TAB) ajoute une string(pour l;autocompletion par exemple) il suffit de la preparer a l'avance,
ensuite vous allez dans get_key, et vous trouvez 

	if (c == K_TAB)
	{
		ft_putendl("LOLWUT");
		sleep(2);
		return (1);
	}

Dans le code au lieu de lolwut vous mettez "add_to_str("la string d'autoomplete")

elle ira se foutre toute seule a l.emplacement du curseur.

Si vous voulez deplacer le curseur, vous pouvez le set a la main en modifiant la variable g_tracking.pos->abs. Faudra pas oublier 
d'appeler correct_pos pour mettre ajour les variable x et y ensuite.

Si vous voulez mettre le curseur a une position de la chaine, oubliez pas d;utiliser utf_strlen sinon ca peut foutre la merde des 
que y'a des accents

(Par exemple si vous faites ft_strlen de "l'unicode m'a cassé les couilles") ca va vous donner 33 charactere(vu que le é est codé 
sur 2 char dans la string, et strlen renvoit juse le nombre de char)

utf_strlen renvoit le nombre de charactere visibles a l'ecran, vous aurez bien 32 et le curseur va pas se décaler.


Mon fichier get_key est encore en bordel mais je vais reorganiser ca.

Pour l;instant quand on appuie sur entree, ca apelle la fonction ft_return. La tout ce qu'elle fait c'est dupliquer la ligne dans 
g_tracking.cmd, puis elle print la commande tapée a l'ecran. Donc c;est la qu;il faudra appeler le parser lexer etc pour aller vers 
la suite du minishell


Pour l;instant la condition de ma boucle "get_key" qui chope les entree clavier c'est "tant que g_tracking.swi" est a 0(swi pour switch)
Quand on appuie sur entree ca set a 1, faudra reset a 0 ensuite pour reprendreles input claviers.
