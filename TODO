MISC
-verifier operateurs fin de ligne
-tester 42sh avec correction du 42sh
- all leaks, norme, gcc -wall -wextra -werror
- proteger si ficher ~/.hist extisteais pas.
-verifier liens symboliques marchent bien sur proompt et pwd
-pouvoir exit completion de -> "ls &&" et "ls ||" et "ls |" avec Ctrl-C et Ctrl-D
-completion "ls |"
-local variable asignation doit etre fait pour chaque commande, pas chaque job
-new tmpenv
-alias a=\caca doit etre set sans '\'
-fix alias sub='(echo abc|)'

  liste comandes difficiles:
-"HAHAHAHEHHE=toto HAHA=XD env | grep HAHA ; a=b c=t caca=xd ; HIHIHI=ta HIHIHIHIHIH=ti env | grep HIHIHI ; set | tail -3"
-"mkdir test ; cd test ; ls -a ; ls | cat | wc -c > fifi ; cat fifi"
-"HOME=XD env | grep HOME= ; a=b ; env -i || ls && HOME=XDA env | grep HOME= || c=d ; HOME=XDO cd"
-"ls | ./42sh" 
-"env -i PATH=/tmp ./42sh"
-"HOME=XD cd ; a=b || ls && HOME=XDA cd || c=d"
-"a=hello b=world; b=42 echo ${a}_${b} && echo ${b}REURS########

========================>ICI


$> rm -rf tempdir; test ! -d tempdir && echo "tempdir removed"
tempdir removed
====>SEGFAULT!!!!!

$> ONESHOT= env | grep ONESHOT
ONESHOT=
====> SEGFAULT

==============>LEAKS<===============

&> (echo 123; echo 456|cat -e;)

&> (echo aaa; exit 42; echo bbb;)|cat -e; echo ccc

$> (ls /) | (cat -e) | (cat -e)

&> (ls /| cat -e) | (cat -e | cat -e) | (cat -e | cat -e)

$> (echo foo; echo bar >out; ls DO_NOT_EXIST) >out 2>err

$> (export ABC=def; env|grep ABC); env|grep ABC|cat -e

$> { export ABC=def; env|grep ABC; }; env|grep ABC|cat -e

$> { echo baz; echo buz >out2; } >out

$> c=8; echo $((123<=123 && 42%42 || c++ + 34))

$> alias hello='echo "hello, world"'
$> hello | cat -e

########EXPANSION#########


$> unset foo 2>&-; echo ${foo:?bar}
{{ Print an error message indicating 'foo' and 'bar' }}
====>Affiche “${foo:=bar}”

$> unset foo 2>&-; echo ${foo:+bar} ${foo}
====>Affiche un ‘\n’


########TEST AST#########


###A VERIFIER###
$> a='hello' b=''; unset c
$> test ${a} && echo ok || echo wrong
ok
$> test ${b} && echo ok || echo wrong
wrong
$> test ${c} && echo ok || echo wrong
wrong
$> test -z ${a} && echo ok || echo wrong
wrong
$> test -z ${b} && echo ok || echo wrong
ok
$> test -z ${c} && echo ok || echo wrong
ok
##################
$> test ${first} -ne ${second} && echo ok || echo wrong
ok
====>expected integer :
====>wrong
$> test -1 -gt -2 && echo ok || echo wrong
ok
====>too many arguments
====>wrong
$> test -2 -lt -2 && echo ok || echo wrong
wrong
====>too many arguments
====>wrong


########QUOTING#########


$> echo 'foo\
> bar' | cat -e
foo\$
bar$
$>
====>foo\bar$
$> echo "foo\
> bar" | cat -e
foobar$
$>
====>foo\bar'$
====>baz$
$> l\
> s \
> -lat
{{ Output of "ls -lat" command }}
====>42sh: command l\ not found
$> echo abc \| cat -e
abc | cat -e
$> echo abc \\| cat -e
abc \$

######ALIAS######

$> alias hello='echo "hello, world"'
$> hello | cat -e
hello, world$
====> LEAKS + 42sh: command hello not found
$> alias hello
{{ Print the alias definition for 'hello'. Something like: hello='echo "hello, world!"' }}
$> alias hello=
$> hello
====> LEAKS + 42sh: command hello not found
$> alias hello
{{ Print the alias definition for 'hello'. Something like: hello= }}
$> alias sub='(echo abc|'
====> LEAKS
$> sub cat -e)
abc$
====> LEAKS + 42sh: command sub not found
$> alias rd='ls DOESTNOEXIST 2>>err'
$> rd; rd; rd
====>LEAKS + 42sh: command rd not found
$> cat err
ls: DOESTNOEXIST: No such file or directory
ls: DOESTNOEXIST: No such file or directory
ls: DOESTNOEXIST: No such file or directory
====> cat: err: No such file or directory
$> alias aa='echo hello' bb='echo world'
$> aa; bb
hello
world
$> alias mk='mkdir -v' abc='def'
$> mk abc
mkdir: created directory 'abc'
$> alias mk='mkdir -v ' abc='def'
$> mk abc
mkdir: created directory 'def'
$> alias
{{ Print all aliases definition }}
$> alias a=alias
$> a aa='echo "alias builtin redefined"'
$> aa
alias builtin redefined
$> alias b=c
$> alias c=d
$> alias d='echo It should works'
$> b
It should works
$> alias e='g'
$> alias f='e'
$> alias g='echo "infinite loop"; e'
$> g
{{ Error message mentionning that the 'g' command is not found }}
$> alias hello='echo "hello, world!"'
$> unalias hello
$> hello
{{ Error message indicating that the 'hello' command is not found }}
$> alias hello='echo "hello, world!"'
$> unalias -a
$> alias
$>

#######TEST 21SH#######

$> doesnotexist
{{ Message d'erreur indiquant que la commande n'existe pas/est introuvable }}
====> LEAKS
$> /sbin/yubikey_shell
{{ Message d'erreur indiquant que la commande ne peut être exécuté pour cause de permission insuffisante }}
====> LEAKS
$> cat <&4
{{ Message d'erreur indiquant que le descripteur de fichier est invalide }}
====> LEAKS
$>
$> exit 1 | exit 2 | exit 3; echo "stayin' alive"
stayin' alive
====> LEAKS
$> echo out >&- | echo out2
{{ Message d'erreur facultatif indiquant qu'il est impossible d'écrire sur stdout }}
out2
====> LEAKS
$> cat << EO\
> F
heredoc> hi
heredoc> EOF
hi
====> NE FONCTIONNE PAS (‘\’)
$> (cat < heredoc> abd
heredoc> abc
heredoc> abb
heredoc> EOF
abb$
abc$
abd$
====> LEAKS
$> echo abc; exit; echo def
abc
zsh%> echo $?
0
====> LEAKS
$> exit 999999999999999999999999999999999999999999
====> LEAKS
$> exit abc
{{ Message d'erreur indiquant qu'une valeur numérique est attendue }}
$> echo ${?}
{{ Code de retour différent de 0 }}
====> LEAKS
$> owd
====>LEAKS
$> cd -L /tmp; cd -P ..
$> pwd
/private
====> Mauvais repertoire (‘/‘)
$> a=hello b=world; b=42 echo ${a}_${b} && echo ${b}
hello_world
world
====> 42
$> directory=/ ls_opt=-atr
$> ls ${ls_opt} ${directory}
{{ Sortie de la commande "ls -atr" sur la racine du système }}
====> ls: fts_open: No such file or directory
$> echo ${empty}|cat -e
$
====> LEAKS
$> set | grep -E '(a|b)='
a=hello
b=world
====> LEAKS
$> env | grep -E '(a|b)='
====> LEAKS
$> env | grep ONESHOT

$> env | grep -E '(a|b)='
$> set | grep -E '(a|b)='
====> LEAKS
$> ls -lR /usr >fifo 2>&1 &
====> Resultat different
$> jobs
{{ Message indiquant que la commande "ls" est en cours d'exécution }}
$>
$> emacs -nw &
$> emacs -nw &
$> emacs -nw &
$> emacs -nw &
$> emacs -nw &
$> jobs
{{ Message indiquant que 5 instances d'emacs sont stoppés en arrière-plan }}
$>
$> fg %{{ un des emacs job number }}
$> jobs
{{ La commande "ls" lancé plus haut doit être la seule restante }}
====> tout les process emacs restent lancés
$> cat -e {{ Sortie de la commande "ls". N'attendez pas la fin, coupez l'affichage avec CTRL-C }}
$> jobs
$>
====> La commande ls ne ce relance pas
$> ls -Rl / 2>&1
{{ Affichage de la commande "ls". N'attendez pas la fin, appuyez sur CTRL-Z }}
{{ Message indiquant que la commande est suspendue }}
$> jobs
{{ Message indiquant que la commande est suspendue }}
$>
$> ps a | grep "ls -Rl /" | grep -v 'grep' | cut -d ' ' -f 2
{{ PID de la commande "ls" du test précédent }}
$> kill {{ PID de la commande "ls" du test précédent }}
$> jobs
{{ Message indiquant que la commande s'est terminé }}
$>
$> jobs
$> ps a | grep "ls -Rl /" | grep -v 'grep'
$>
$> python -c 'import os, signal;os.kill(os.getpid(), signal.SIGSEGV)'
{{ Message indiquant le signal reçu }}
$>
